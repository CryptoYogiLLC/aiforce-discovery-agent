"""Vulnerability scanning for dependencies using OSV database.

This module is HARD-DISABLED by default and requires explicit opt-in.
Supports both online (OSV API) and offline (local database) modes.

Security note: This scanner should only be enabled in environments where
network access to OSV API is approved or a local database is available.
"""

import json
import logging
from pathlib import Path
from typing import Any

logger = logging.getLogger(__name__)

# Default path for offline vulnerability database
DEFAULT_OFFLINE_DB_PATH = "/data/osv-database.json"

# OSV API endpoint (only used when online mode is enabled)
OSV_API_URL = "https://api.osv.dev/v1/query"


class VulnerabilityScanner:
    """
    Scans dependencies for known vulnerabilities.

    IMPORTANT: This scanner is DISABLED by default. To enable:
    1. Set enabled=True in constructor, OR
    2. Set CODEANALYZER_VULN_SCAN_ENABLED=true environment variable

    For air-gapped environments, provide a local database path.
    """

    def __init__(
        self,
        enabled: bool = False,
        offline_mode: bool = True,
        db_path: str | None = None,
    ):
        """
        Initialize the vulnerability scanner.

        Args:
            enabled: Whether scanning is enabled (default: False - HARD DISABLED)
            offline_mode: Use local database instead of API (default: True)
            db_path: Path to local OSV database file (for offline mode)
        """
        self._enabled = enabled
        self._offline_mode = offline_mode
        self._db_path = Path(db_path) if db_path else Path(DEFAULT_OFFLINE_DB_PATH)
        self._vuln_db: dict[str, list[dict[str, Any]]] | None = None

        if self._enabled:
            logger.info(f"Vulnerability scanner ENABLED (offline_mode={offline_mode})")
            if offline_mode:
                self._load_offline_db()
        else:
            logger.info("Vulnerability scanner DISABLED (default)")

    def _load_offline_db(self) -> None:
        """Load the offline vulnerability database."""
        if not self._db_path.exists():
            logger.warning(
                f"Offline vulnerability database not found at {self._db_path}. "
                "Vulnerability scanning will return empty results."
            )
            return

        try:
            with open(self._db_path) as f:
                data = json.load(f)

            # Index by package name for fast lookup
            self._vuln_db = {}
            for vuln in data.get("vulnerabilities", []):
                for affected in vuln.get("affected", []):
                    package = affected.get("package", {})
                    ecosystem = package.get("ecosystem", "").lower()
                    name = package.get("name", "").lower()
                    key = f"{ecosystem}:{name}"

                    if key not in self._vuln_db:
                        self._vuln_db[key] = []
                    self._vuln_db[key].append(vuln)

            logger.info(
                f"Loaded offline vulnerability database with "
                f"{len(self._vuln_db)} packages"
            )
        except Exception as e:
            logger.error(f"Failed to load offline vulnerability database: {e}")
            self._vuln_db = None

    def scan(self, dependencies: list[dict[str, Any]]) -> list[dict[str, Any]]:
        """
        Scan dependencies for vulnerabilities.

        Args:
            dependencies: List of dependencies from DependencyExtractor

        Returns:
            List of dependencies with vulnerability information added
        """
        if not self._enabled:
            logger.debug("Vulnerability scanning skipped (disabled)")
            return []

        if self._offline_mode:
            return self._scan_offline(dependencies)
        else:
            return self._scan_online(dependencies)

    def _scan_offline(self, dependencies: list[dict[str, Any]]) -> list[dict[str, Any]]:
        """Scan using local database."""
        if not self._vuln_db:
            return []

        results = []
        ecosystem_map = {
            "npm": "npm",
            "pip": "pypi",
            "poetry": "pypi",
            "go": "go",
            "maven": "maven",
            "gradle": "maven",
            "cargo": "crates.io",
            "bundler": "rubygems",
            "composer": "packagist",
        }

        for dep in dependencies:
            name = dep.get("name", "").lower()
            version = dep.get("version", "")
            pkg_manager = dep.get("package_manager", "").lower()
            ecosystem = ecosystem_map.get(pkg_manager, pkg_manager)

            key = f"{ecosystem}:{name}"
            vulns = self._vuln_db.get(key, [])

            dep_vulns = []
            for vuln in vulns:
                if self._version_affected(version, vuln):
                    dep_vulns.append(self._format_vulnerability(vuln))

            if dep_vulns:
                results.append(
                    {
                        "name": dep.get("name"),
                        "version": version,
                        "ecosystem": ecosystem,
                        "vulnerabilities": dep_vulns,
                    }
                )

        return results

    def _scan_online(self, dependencies: list[dict[str, Any]]) -> list[dict[str, Any]]:
        """Scan using OSV API (requires network access)."""
        # Import here to avoid dependency when offline-only
        try:
            import httpx
        except ImportError:
            logger.error("httpx not installed. Install with: pip install httpx")
            return []

        results = []
        ecosystem_map = {
            "npm": "npm",
            "pip": "PyPI",
            "poetry": "PyPI",
            "go": "Go",
            "maven": "Maven",
            "gradle": "Maven",
            "cargo": "crates.io",
            "bundler": "RubyGems",
            "composer": "Packagist",
        }

        for dep in dependencies:
            name = dep.get("name", "")
            version = dep.get("version", "")
            pkg_manager = dep.get("package_manager", "").lower()
            ecosystem = ecosystem_map.get(pkg_manager)

            if not ecosystem or not version or version == "*":
                continue

            try:
                response = httpx.post(
                    OSV_API_URL,
                    json={
                        "package": {"name": name, "ecosystem": ecosystem},
                        "version": version.lstrip("^~>=<"),
                    },
                    timeout=10.0,
                )
                response.raise_for_status()
                data = response.json()

                vulns = data.get("vulns", [])
                if vulns:
                    results.append(
                        {
                            "name": name,
                            "version": version,
                            "ecosystem": ecosystem,
                            "vulnerabilities": [
                                self._format_vulnerability(v) for v in vulns
                            ],
                        }
                    )
            except Exception as e:
                logger.warning(f"OSV API query failed for {name}: {e}")

        return results

    def _version_affected(self, version: str, vuln: dict[str, Any]) -> bool:
        """Check if a version is affected by a vulnerability."""
        # Simplified version check - in production, use semver comparison
        if not version or version == "*":
            return False

        version = version.lstrip("^~>=<")

        for affected in vuln.get("affected", []):
            for range_obj in affected.get("ranges", []):
                for event in range_obj.get("events", []):
                    if "fixed" in event:
                        # Version is affected if it's before the fix
                        # This is a simplified check
                        return True

        return False

    def _format_vulnerability(self, vuln: dict[str, Any]) -> dict[str, Any]:
        """Format vulnerability data for output."""
        severity = "unknown"
        for s in vuln.get("severity", []):
            if s.get("type") == "CVSS_V3":
                score = float(s.get("score", "0").split("/")[0])
                if score >= 9.0:
                    severity = "critical"
                elif score >= 7.0:
                    severity = "high"
                elif score >= 4.0:
                    severity = "medium"
                else:
                    severity = "low"
                break

        # Find fixed version
        fixed_version = None
        for affected in vuln.get("affected", []):
            for range_obj in affected.get("ranges", []):
                for event in range_obj.get("events", []):
                    if "fixed" in event:
                        fixed_version = event["fixed"]
                        break

        return {
            "id": vuln.get("id", ""),
            "severity": severity,
            "summary": vuln.get("summary", "")[:200],  # Truncate long summaries
            "fixed_version": fixed_version,
        }

    @property
    def is_enabled(self) -> bool:
        """Check if vulnerability scanning is enabled."""
        return self._enabled

    @property
    def is_offline_mode(self) -> bool:
        """Check if running in offline mode."""
        return self._offline_mode
